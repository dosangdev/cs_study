4장. 인터넷 구조를 알아보자
---

### 38. 인터넷의 구조
#### - 인터넷의 기원
1960년대부터 ARPANET을 이용해 미국 내 대학과 연구기관을 연결한 것이 인터넷의 기원. 이후 패킷 통신 방식과 TCP 프로토콜 또한 ARPANET 프로젝트에서 얻은 성과이다.
네트워크끼리 서로 연결한다는 의미에서 인터넷(internet)이라고 불렀다.

#### - 인터넷의 구조
인터넷은 연결된 라우터끼리 패킷을 주고 받는 패킷 통신 방식이다.
라우터의 기본 역할은
1. LAN 내부 통신은 내부에서 처리한다.
2. 자신이 관리하는 LAN 주소로 온 통신이 아니면 내부로 들이지 않는다.
3. 이 경우 라우팅 테이블을 참고해 다른 라우터로 토스하거나 기본 게이트웨이로 전달한다.

### 39. 인터넷에서 사용하는 프로토콜
#### - TCP/IP 기반의 서비스 프로토콜
TCP/IP 프로토콜은 IP 주소를 기반으로 패킷을 전송하는 기능밖에 없기 때문에, 패킷 도달 여부, 재전송 확인 등의 역할인 애플리케이션이 담당한다. 

그 외에 더 복잡한 기능을 구현하기 위해서는 더 많은 서비스 프로토콜이 필요하다.

이 때 애플리케이션이 사용하는 프로토콜을 **서비스 프로토콜(애플리케이션 프로토콜)**이라고 한다. TCP/UDP/IP 프로토콜을 기반으로 구현하고 있다.

이전에 배운 잘 알려진 포트의 대부분은 서비스 프로토콜에 할당되어 있다.

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/0cad5e7d-f4ad-4fa3-8383-02bff7e90f3b)


###### * RFC(Request for comments) : IETF에서 관리하는 문서. 인터넷 개발에 있어 필요한 거의 모든 인터넷 표준을 문서화한 것.

### 40. 이메일을 주고받는 구조

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/7f9caf76-1e07-4124-abf4-583535a1e773)


#### - SMTP로 이메일 보내기
>SMTP : 이메일을 보낼 때 사용하는 프로토콜

1. 자사의 메일 서버로 이메일을 전송 - SMTP 서버
2. 받는 사람의 이메일 주소의 도메인 이름을 확인, DNS를 이용하 IP 주소 얻음 
3. 해당하는 서비스의 수신 메일 서버로 전송

#### - POP로 이메일 받기
>POP : 이메일을 수신할 때 사용하는 프로토콜

1. 송신 메일 서버로부터 받은 이메일에 대해, 각 사용자 ID에 해당하는 스풀 파일(임시 파일)에 이메일 저장
2. 메일 클라이언트가 수신 메일 서버에 접속 - POP 서버
3. 등록 사용자 데이터베이스를 이용해 정상 사용자로 인증되면 해당 이메일 파일을 로컬 컴퓨터로 다운로드
4. 다운로드된 이메일은 스풀 파일에서 삭제

#### - IMAP 
> IMAP : POP과 마찬가지로 이메일을 수신할 때 사용하는 또 다른 프로토콜
메일 서버 메일함에서 이메일을 직접 관리하고, 서버에 접속하여 이메일을 확인하는 방식. 기기의 제약X

#### - 메일 프로토콜의 보안
메일 프로토콜은 보안 기능이 구현되어 있지 않기 때문에 메일 전송 전에 발신자 인증, 암호화 등 프로토콜을 확장하거나 추가해야한다.

### 41. 웹 페이지를 열람하는 구조
#### - 웹
>웹 : World Wide Web

1. 클라이언트-서버형 네트워크
2. TCP/IP, HTTPS, DNS 등의 인프라 기술 이용
3. HTML/JS/Java, SQL, REST API 등으로 구성. 

이런 기술을 통해 웹 페이지, 실시간 동영상 송출... 웹의 활용방안은 무궁무진하다
그리고 우리가 공부하고 있는 기술이기도 하다. 우리는 웹개발자!

#### - 웹의 기본 구조

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/d8395dce-dfa1-42e5-8778-464f1f63cfcf)


웹은 HTML 형식의 문서를 웹 서버에 저장하고, 웹 클라이언트(브라우저)가 서버에 액세스하여 HTML 문서를 화면에 표시한다.

웹 서버로는 Apache, IIS, Nginx 등이 있고, 웹 브라우저는 크롬, 사파리 등이 있다.

### 42. URL/URI

<img width="501" alt="image" src="https://github.com/Minnie5382/devduck-cs-study/assets/97179789/e7287d4b-778c-4b0a-9edb-8beecd6a6f8f">



>URL(Uniform Resource Locator) : 인터넷 상의 리소스의 **위치**를 특정하는 방법
>
>URI(Uniform Resource Identifier) : 인터넷 상의 **리소스 자체**를 특정하는 방법
###### * 리소스 : 네트워크 상의 서버, 내부 데이터, 애플리케이션, 기능 등의 자원


#### - URL 구조

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/f2b63079-3d14-4bb2-b25e-97083a3c5587)

>스키마 = 프로토콜
>
>경로 : 웹 서버에서 해당 파일의 경로를 계층 구조로 표시
>
>쿼리 = 변수, 파라미터. 
>
> 프래그먼트(앵커) : 책갈피. 서버로 전송되지 않고 브라우저가 처리.

#### - 액티브 파라미터 vs 패시브 파라미터
>액티브 파라미터 : 쿼리에 지정된 데이터에 의해 표시되는 내용이 변함
> 
>패시브 파라미터 : 표시되는 내용과 무관한 참조 정보 (ex. 추천인 링크)

### 43. HTTP/HTTPS 
> HTTP : 웹 브라우저가 웹 서버에게 API 요청을 보낼 때 애플리케이션 계층에서 사용하는 프로토콜. URL + HTML
>
> HTTPS : HTTP + SSL/TLS 암호화
> 
#### - 웹 브라우저의 캐싱
HTTP 통신은 스테이트리스 (전후 통신과 관계없이 매 통신이 독립적으로 처리됨)이기 때문에 리소스 낭비가 크다.

그래서 브라우저에서는 한번 접속한 웹의 HTML 파일 등을 보관해두었다가(캐시), 두번째 접속부터는 서버를 접속하지 않고 캐싱된 정보를 사용하여 화면을 렌더링.













### 44. DNS
>DNS(Domain Name System) : 도메인 이름 - IP 주소의 대응표를 관리하는 시스템
>
>DNS 서버 : DNS를 이용하여 대응표를 관리하는 서버. 여러 서버에 DB를 분산하고, 서버끼리 통신하며 작동한다.

#### - 도메인 이름
IP 주소는 인간이 보기엔 숫자의 나열일 뿐이기 때문에, IP 주소에 인간이 다루기 쉬운 이름을 지정한 것. 

IP 주소가 계층 구조를 갖고 있듯이, 도메인 이름도 계층적으로 정보를 추가한다. 


![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/36ca01a2-800a-4f66-8861-afa4ab903025)


#### - 도메인 이름 - IP 주소 관리 방법
여러 개의 권한 DNS 서버(네임 서버)에 대응표 데이터베이스를 분산시켜 관리한다. 

DNS 서버의 영역 : 하나의 DNS 서버가 관리하는 대응표 범위

> 클라이언트가 IP 주소를 요청할 때, LAN 내 DNS 서버가 알고 있을 경우 IP 주소를 직접 알려주고, 모른다면 알고 있을 것 같은 DNS 서버에 문의한다.
>
> 이런 문의를 처리하는 프로그램을 **리졸버**라고 한다.

#### - www.naver.com을 주소창에 치고 엔터를 누르면 어떻게 되나요?

[유튜브 채널 '큰돌의터전 - www.naver.com을 주소창에 치면 무슨 일이 일어날까요?']("https://www.youtube.com/embed/YahjHM9UNCA?si=hPWhqjYu_nuzNUhD_") 내용 정리

>1. www.naver.com을 주소창에 입력한다.
>2. 리다이렉트/캐싱을 확인한다.
>   다른 페이지로 전환되는 리다이렉트나, 브라우저 캐시 등에 저장된 캐시가 있는지 확인하고, 있다면 가져온다.
>3. DNS (네임 해석)
>   도메인 네임의 계층 구조를 이용하여 FQDN -> IP 주소로 변환한다.
>4. IP 주소 라우팅
>   알아낸 IP 주소를 이용해서 라우팅한다.
>5. TCP 연결 구축 - 3-way handshake
>6. 데이터 통신 (컨텐츠 다운로드)
>7. 브라우저 렌더링


### 45. ICMP
#### - ICMP의 역할
> ICMP : 네트워크 계층에서 TCP/UDP와 더불어 사용되는 프로토콜.

ICMP의 주 업무는 처리 실패, 장애 발생 시 오류 메시지를 통지하는 것이다.

또한 목적지와 통신의 전/후처리, 관리 정보 등을 교환하고, 목적지의 상태, 호스트가 작동하는지 등을 확인하는 용도

-> 네트워크 통신의 관리자 역할!

#### - ICMP 패킷의 구조

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/64e257c2-c36c-425b-9b13-399bc0bb705e)

TCP/IP 패킷과 마찬가지로 ICMP 헤더에는 타입, 코드, 체크섬 필드가 있다. 위 그림은 ICMP 헤더가 IP 패킷의 페이로드가 들어가 있는 모습이다.

TCP 패킷과 달리 ICMP패킷은 가변 길이를 갖는다.

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/a8eb90e4-e45e-43c7-a566-0a51a8db4231)


>type = 패킷의 종류. TCP/UDP/ICMP 인지
>
>code = 통신 코드
>
>체크섬 = 패킷이 온전히 도착했을 지 확인하기 위해 사용되는 부호. 페이로드를 어떻게 어떻게 계산해서 나온 값이 들어간다.
>목적지에서는 이 체크섬 값을 이용해 패킷이 온전한지 확인한다.

#### - ICMP 주요 타입과 3 타입의 주요 코드
##### ICMP 주요 타입
|타입 | 의미 |
|-|-|
|0 | 호스트의 생사 확인|
|3|목적지 도달 불가|
|5|기본 게이트웨이 이외의 경로 지정|

-> 주로 타입 3가 자주 발생한다.

##### 3 타입의 주요 코드

![image](https://github.com/Minnie5382/devduck-cs-study/assets/97179789/9c1800f3-37a5-4718-be35-ee54aca1e2ef)


### 46. 텔넷
> 텔넷 : 단말기에서 서버에 원격으로 로그인하는 프로토콜

- 텔넷은 클라이언트-서버형 프로토콜이다.
- 단말기는 키보드와 디스플레이를 사용하여 텍스트 데이터로 서버에 접속하여 원격으로 OS 관리나 네트워크 설정 등을 할 수 있다.
- 리눗그, macOS에서는 텔넷 서버가 백그라운드 프로세스로 항상 실행되고 있다.

#### - 텔넷의 문제점
텔넷을 이용해 원격으로 서버에 접속할 때 로그인 ID와 비밀번호를 입력하는데, 이런 정보들은 암호화되지 않은 평문 형태로 통신되기 때문에 도청의 위험이 높다.

-> 현재는 텔넷보다 SSH를 사용한다.


### 47. SSH
> SSH : 텔넷을 대신해서 원격 로그인에 이용되는 프로토콜. **공개키 암호화 방식**을 통해 원격 접속을 암호화.

#### - 공개키 암호화 방식
HTTPS와 SSH에서 사용하는 암호화 방식.

>공개키와 개인키는 한 쌍의 키이다. 공개키는 네트워크상에 공개하는 키, 개인키는 비공개 키.
>
>공개키를 알고 있어도 그에 대응하는 올바른 개인키가 없다면 암호문을 복호화 할 수 없다.

>공개키 저장소에 자신의 공개키를 등록하면, 3자가 그 공개키를 획득한다.
>
>획득한 공개키로 평문을 암호화하여 나에게 전송하면, 나는 개인키로 암호문을 복호화 할 수 있다.

#### - SSH1
1. A가 B에게 공개키를 받는다
2. A는 받은 공개키로 데이터를 암호화 하여 공통키를 생성하고, 암호문을 B에게 전송한다.
3. B는 받은 암호문을 자신의 개인키로 복호화 하여 공통키를 생성한다.
4. 이후 통신은 공통키로 암호화한다.

#### - SSH2 (디피-헬만 키 교환 방식)
1. A와 B가 각자 개인키, 공개키를 생성한다.
2. 서로 공개키를 교환한다.
3. A와 B가 서로의 공개키와 자신의 개인키로 암호화 하여 공통키를 생성한다.
4. 공통키를 서로 교환한다. 이후 통신은 공통키로 암호화한다.
5. A와 B는 받은 암호문을 자신의 개인키로 복호화하면 평문을 얻을 수 있다.


### 48. FTP
> FTP : 파일을 주고 받을 때 사용하는 프로토콜. 클라이언트-서버형.

클라이언트가 FTP 서버에 로그인하면 서버에 있는 파일을 내려받거나 파일을 업로드 할 수 있다.

일반적으로 무료 소프트웨어이지만, 텔넷과 마찬가지로 로그인 정보가 암호화되지 않아 보안 상 문제점이 있다.

-> SCP나 SFTP 등으로 대체되고 있다.

#### - 액티브 vs 패시브
FTP의 포트는 21번 (컨트롤 포트), 20번 (데이터 포트)을 사용한다.
- 데이터 포트(20) : 서버끼리 파일을 전송할 때 사용.(액티브 모드) 클라이언트와의 통신은 임의의 포트를 네고시에이션하여 사용.)패시브 모드)
- 컨트롤 포트(21) : 세션을 관리하는 데 사용.

이렇게 나눠놓은 이유는 파일 전송 중에도 중단 등의 관리를 할 수 있도록 하기 위함이다.

### 49. NTP
> NTP(Network Time Protocol) : 인터넷 상의 모든 서비스의 시간을 동기화하는 프로토콜. 클라이언트-서버형.
 

클라이언트는 NTP 서버에 현재 시각을 문의하고, 서버는 현재 시각을 응답한다. (GPS 시계, 표준 시계 등의 시각)

인터넷에서 NTP 서버 문의량은 너무나 많기 때문에 NTP 서버는 계층적으로 배치된다.

<img width="600" alt="image" src="https://github.com/Minnie5382/devduck-cs-study/assets/97179789/a469287e-34ed-44d3-b2a3-e3bbda49a032">

 
### 50. 그 밖에 - Ajax, REST API

> Ajax(Asynchronous JS + XML) : XML 형식으로 비동기 통신을 하는 것
>
> REST API : HTTP 통신에서 사용되는 API 이용 방법에 대한 규약. DB, 백엔드 시스템 호출 시 사용됨.


<img width="701" alt="image" src="https://github.com/Minnie5382/devduck-cs-study/assets/97179789/6e4aab9c-6f01-40eb-a782-98e817253d65">

