# 가상 메모리

## 14-1 연속 메모리 할당

    연속 메모리 할당은 연속적인 메모리 공간을 할당하는 방식입니다.
    ex) 사용자 영역에서 프로세스A는 A의 크기만큼 메모리 주소를 할당받아 연속적으로 배치되고,
        프로세스B는 프로세스A 이후에 또 B의 크기만큼 연속적인 메모리 주소를 할당받아 배치되는 식
    -> 프로세스들이 메모리에 연속적으로 할당할 때 무엇을 고려해야하는지, 어떤 잠재적인 문제가 있는지

### 스와핑

- 메모리에 적재된 프로세스들 중에 현재 실행되지 않는 프로세스를 임시로 **스왑 영역**으로 보내고 남은 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식

- 스왑아웃 되었던 프로세스가 다시 스왑인될 때는 스왑아웃전에 갖던 물리 주소와는 다른 주소에 적재될 수 있다.
- 스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.
  ![스와핑 동시 실행 img] (https://velog.velcdn.com/images/mm723/post/ccef257c-4ca7-4c64-b5d2-8ee010416874/image.png)

#### 용어

- 스왑 영역: 프로세스들이 쫓겨나는 보조기억장치의 일부 영역
- 스왑 아웃: 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것
- 스왑 인: 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것

### 메모리 할당(비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식)

- 상황: 20MB 크기의 프로세스를 적재하고 싶을 때
  ![예시 상황 img] (https://velog.velcdn.com/images/thdgusrbek/post/598b7805-1b8b-42c8-9ab5-1f4889ca4828/image.png)

- 최초적합: 운영체제가 메모리 내의 빈 공간을 **순서대로 검색하다가** 적재할 수 있는 공간을 **발견하면** 그 공간에 프로세스를 배치하는 방식

  - 빈 공간 A에 배치
  - 검색을 최소화, 빠른 할당

- 최적적합: 빈 공간을 **모두 검색해 본 후**, 프로세스가 **적재될 수 있는 공간 중 가장 작은 공간**에 프로세스를 배치하는 방식

  - 빈 공간 C에 배치

- 최악접합: 빈 공간을 **모두 검색해 본 후**, 프로세스가 **적재될 수 있는 공간 중 가장 큰 공간**에 프로세스를 배치하는 방식
  - 빈 공간 B에 배치

### 외부 단편화

    연속 메모리 할당은 외부 단편화라는 문제를 내포하고 있기 때문에 메모리를 효율적으로 사용하는 방법이 아닙니다.

- 프로세스들이 메모리에 연속적으로 할당되는 환경에서는 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다. 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이러한 현상을 **외부 단편화**(external fragmentation)

- 해결 빙법
  - 압축: 흩어져 있는 빈 공간들을 하나로 모으는 방식
    - 단점
      - 모으는 동안 시스템은 하던 일을 중지
      - 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기
  - 페이징 기법

<hr/>

## 14-2 페이징을 통한 가상 메모리 관리

- 연속 메모리 할당 방식의 문제점
  - 외부 단편화, 물리 메모리보다 큰 프로세스를 실행할 수 없다
    - 해결: 가상메모리로 실행하고자 하는 프로그램을 일부만 메로리에 적재하여 실제 물리 메모리크기보다 더 큰 프로세스를 실행할 수 있게 하는 기술.
      - 가상 메모리의 기법
        - 페이징
        - 세그멘테이션

### 페이징이란

- 메모리의 물리 주소 공간을 **프레임** 단위로 자르고, 프로세스의 논리 주소 공간을 **페이지** 단위로 자른 뒤 각 페이지를 프레임에 할당하는 가상 메모리 관리 기법
- 페이징에서 스와핑: 페이지 단위로 페이지 아웃/페이지 인
  프로세스를 이루는 페이지 중 실행에 필요한 일부 페이지만을 메모리에 적재하고, 당장 실행에 필요하지 않은 페이지들은 보조기억장치에 남겨둘 수 있다.

### 페이지 테이블

    프로세스가 메모리에 불연속적으로 배치되어 있다면 프로세스를 이루는 페이지가 어느 프레임에 적재되어 있는지
    CPU가 알기 어렵기 때문에 순차적으로 실행할 수 없습니다.

- 페이징 시스템은 프로세스가 물리주소에 불연속으로 배치되더라도 논리주소에는 연속적으로 배치되도록 페이지 테이블을 이용한다.
- 페이지테이블은 페이지 번호와 프레임 번호를 짝지어준다.
- 프로세스마다 각자의 **프로세스 테이블**을 가지고 있고, 각 프로세스의 페이지 테이블들은 **메모리에 적재**되어 있다.\
- CPU내의 **페이지 테이블 베이스 레지스터**(PTBR)는 각 프로세스의 페이지 테이블이 적재된 주소를 가리킨다.
- 페이지 테이블을 메모리에 두면 메모리 접근시간이 두 배로 늘어나는 문제가 생긴다.
  - 해결 방법
    - CPU 곁에 TLB라는 페이지 테이블의 캐시메모리(참조지역성에 근거해 주로 최근에 사용도니 페이지 위조로 가져와 저장)를 둔다.
    - CPU가 발생한 논리 주소에 대한 페이지 번호가 TLB에 있을 경우 이를 **TLB히트**라고 한다.
      - 이 경우 페이지가 적재된 프레임을 알기 위해 메모리에 접근할 필요 없다.
    - TLB에 페이지 번호가 없을 경우 메모리 내의 페이지 테이블에 접근한다. 이를 **TLB미스**라고 한다.

### 페이징에서의 주소 변환

- 페이지 번호와 변위: CPU가 생성하는 논리적 주소는 페이지 번호(page number)와 변위(offset)으로 구성됩니다.

  - 페이지 번호: 접근하고자 하는 페이지 번호
    - 페이지 테이블에서 해당 페이지 번호를 찾으면 페이지가 어떤 프레임에 할당되었는지를 알 수 있다.
  - 변위: 접근하려는 주소가 프레임의 시작 번지로부터 얼마큼 떨어져 있는지를 알기 위한 정보
    - 논리 주소 <페이지 번호, 변위>는 페이지 테이블을 통해 물리주소 <프레임 번호, 변위>로 변환된다.

- 페이지 테이블: 논리 주소의 페이지 번호는 페이지 테이블을 통해 해당하는 프레임 번호로 변환됩니다.

### 페이지 테이블 엔트리

    페이지 테이블의 각각의 행들을 페이지 엔트리라고 한다.
    페이지 엔트리에 담기는 정보는 페이지번호, 프레임번호 말고도 유효 비트, 보호 비트, 참조 비트, 수정 비트 등이 있다.

- 유효 비트

  - 기능: 유효 비트는 페이지가 물리 메모리에 존재하는지를 나타냅니다.
  - 상태
    - 1: 해당 페이지가 물리 메모리에 로드(적재)되어 있음을 나타내고, 접근이 가능하다는 것을 의미한다.
    - 0: 페이지가 물리 메모리에 없음을 나타내며, 접근하려고 하면 **페이지 폴트(page fault)**가 발생한다.
  - 페이지 폴트를 처리하는 과정(하드웨어 인터럽트를 처리하는 과정과 유사)
    - 1.CPU는 기존의 작업 내역을 백업한다.
    - 2.페이지 폴트 처리 루틴을 실행한다.
    - 3.페이지 처리 루틴은 원하는 페이지를 메모리로 가져온 뒤 유효 비트를 1로 변경해준다.
    - 4.처리하면 이제 CPU는 해당 페이지에 접근할 수 있다.

- 보호 비트

  - 기능: 보호 비트는 페이지에 대한 접근 권한(읽기, 쓰기, 실행)을 제어한다.
  - 상태
    - 1: 쓰기 기능을 의미하고, 내용을 변경할 수 있다
    - 0: 읽기 전용 모드이고, 내용을 변경할 수 없다.
  - 세 개의 비트로 구현

    - R (Read)

      - 0: 읽기 금지 - 프로세스는 페이지 내용을 읽을 수 없다.
      - 1: 읽기 허용 - 프로세스가 페이지의 데이터를 읽을 수 있다.

    - W (Write)

      - 0: 쓰기 금지 - 프로세스는 페이지 내용을 변경할 수 없다.
      - 1: 쓰기 허용 - 프로세스가 페이지에 데이터를 쓸 수 있다.

    - X (Execute)

      - 0: 실행 금지 - 프로세스는 페이지 내용을 실행할 수 없다.
      - 1: 실행 허용 - 페이지를 실행 코드로 사용할 수 있다.

- 참조 비트

  - 기능: 참조 비트는 해당 페이지가 최근에 참조(접근)되었는지를 나타낸다. 이 비트는 페이지 교체 알고리즘에서 중요한 역할을 한다.
  - 상태
    - 1: 페이지가 최근에 참조(접근)되었음을 나타낸다.
    - 0: 페이지가 최근에 참조되지 않았음을 나타낸다.

- 수정 비트

  - 기능: 수정 비트는 해당 페이지가 수정(쓰기 작업)되었는지를 나타낸다.
  - 상태
    - 1: 페이지가 수정되었음을 나타냅니다. 페이지가 메모리에서 변경된 후 디스크에 아직 반영되지 않았다는 것을 의미한다.
    - 0: 페이지가 수정되지 않았음을 나타냅니다. 페이지에 쓰기 작업이 수행되지 않았거나, 수정된 내용이 디스크에 이미 저장되어 메모리와 디스크의 내용이 일치함을 의미한다.

  <hr/>

## 14-3 페이지 교체와 프레임 할당

### 요구 페이징

- 프로세스를 메모리에 적재할 때 처음부터 모든 페이지를 적재하지 않고 필요한 페이지만을 메모리에 적재하는 기법
- 요구 페이징의 양상

  - 1.CPU가 특정 페이지에 접근하는 명렁어를 실행
  - 2.해당 페이지가 현재 메모리에 있을 경우 (유효 비트가 1일 경우) CPU는 페이지가 적재된 프레임에 접근한다.
  - 3...없을 경우(유효 비트가 0일 경우) 페이지 폴트가 발생한다.
  - 4.페이지 폴트 처리 루틴은 해당 페이지를 메모리로 적재하고 유효 비트를 1로 설정한다.
  - 5.다시 1번을 수행한다.

- 안정적으로 작동하기 위한 2가지

  - 페이지 교체
  - 프레임 할당

- 순수 요구 페이지: 아무런 페이지도 메모리에 적재하지 않은 채 무작정 실행하는 기법
  - 프로세스의 첫 명령어를 실행하는 순간부터 페이지 폴트가 계속 발생한다.
  - 실행에 필요한 페이지가 어느 정도 적재된 이후부턴 페이지 폴트 발생 빈도가 떨어진다.

### 페이지 교체 알고리즘

    페이지 교체 알고리즘을 제대로 이해하려면 페이지 폴트 횟수를 알 수 있어야 한다.
    횟수는 페이지 참조열을 통해 알 수 있습니다.

- FIFO(First-In, First-Out) 페이지 교체 알고리즘

  - 가장 오래 전에 메모리에 적재된 페이지부터 교체한다.

- 최적 페이지 교체 알고리즘

  - CPU에 의해 참조되는 횟수를 고려하는 페이지 교체 알고리즘(앞으로의 사용빈도가 가장 낮은 페이지를 교체하는 알고리즘을 페이지 교체 알고리즘으로 삼는 것)
  - 페이지 폴트의 발생 빈도가 가장 낮다.
  - 실제 구현이 어렵다(오랫동안 사용되지 않을 페이지를 예측하기가 어렵기 때문).
  - 주로 다른 페이지 교체 알고리즘의 이론상 성능을 평가하기 위한 목적으로 사용됨
    - 최적 페이지 교체 알고리즘을 실행했을때의 발생하는 페이지 폴트 횟수를 페이지 폴트의 하한선으로 잡고 다른 알고리즘과 비교해서 평가

- LRU(Least Recently Used) 페이지 교체 알고리즘
  - 가장 오랫동안 사용되지 않은 페이지를 교체한다.

### 스래싱과 프레임 할당

- 스레싱(Thrashing)

  - 프로세스가 너무 자주 페이지를 교체해야 할 때, CPU 사용률이 감소하고, 페이지 교체에 대한 오버헤드가 증가하는 현상
  - 이를 방지하기 위해 적절한 프레임 할당이 필요하다.
  - 스레싱 그래프

    - ![스레싱그래프img] (https://itwiki.kr/w/%EC%8A%A4%EB%A0%88%EC%8B%B1#/media/%ED%8C%8C%EC%9D%BC:%EC%8A%A4%EB%A0%88%EC%8B%B1_%EA%B7%B8%EB%9E%98%ED%94%84.png)

    - 세로축으로 CPU의 이용률을 볼 수 있고, 가로축인 멀티 프로그래밍의 정도를 통해 메모리에 올라와 있는 프로세스의 수를 알 수 있다.
    - 멀티프로그래밍의 정도: 메모리에서 동시 실행되는 프로세스의 수

    - 프레임 할당(Frame Allocation)

  스래싱이 발생하는 근본적인 원인은 각 프로세스가 필요로 하는 최소한의 프레임 수가 보장되지 않았기 때문이다.
  운영체제는 각 프로세스들이 무리 없이 실행하기 위한 최소한의 프레임 수를 파악하고 프로세스들에 적절한 수만큼 프레임을 할당해 줄 수 있어야 한다.

- 프레임 할당 방식
  - 균등 할당: 모든 프로세스에 동일한 프레임을 배분하는 방식 - 비합리적
  - 비례 할당: 프로세스 크기에 따라 프레임을 배분하는 방식
  - 프로세스의 크기가 크거나 작더라도 실행해보면 더 적거나 많은 프레임을 사용하는 경우가 있기 때문에 결국 실행해봐야 아는 경우가 많다.
- 프로세스를 실행하는 과정에서 배분할 프레임을 결정하는 방식(=동적 할당 방식)

  - 작업 집합 모델(WSM): '프로세스가 일정 기간 동안 참조한 페이지 집합'을 기억하여 빈번한 페이지 페이지 교체를 방지

    - 작업집합: 실행 중인 프로세스가 일정 시간 동안 참조한 페이지의 집합

  - 페이지 폴트 빈도(PFF):페이지 폴트율에 상한선과 하한선을 정하고, 그 내부 범위 안에서만 프레임을 할당하는 방식
