# 명령어

## 3-1 소스 코드와 명령어

### 고급 언어와 저급 언어

- 고급언어: 사람을 위한 언어(프로그래밍 언어 - C, C++, Java, Python)
- 저급언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어
  - 명령어로 이뤄져있고 이것만 컴퓨터가 이해 가능하다. 다른 언어는 이해x
  - 종류
    - 기계어: 0과 1의 명령어 비트로 이루어진 언어
      - 가독성을 위해 십육진수로 표현하기도 함
    - 어셈블리어: 기계어를 읽기 편한 형태로 번역한 언어
      - 프로그램이 어떤 절차로 작동하는지를 가장 근본적인 단계에서부터 하나하나 추적하고 관찰할 수 있기 때문에 어떤 개발자가 되길 희망하는지에 따라 익히면 좋다.

### 컴파일 언어와 인터프리터 언어

    고급언어로 작성한 소스코드는 컴퓨터가 읽기 위해 저급언어로 변환되어 실행된다 여기서 변환은 컴파일 방식과 인터프리터  방식이 있다.

- 컴파일언어: 컴파일러에 의해 소스 코드 전체가 저급언어로 변환되어 실행되는 고급언어

  - 컴파일(compile): 컴파일 언어로 작성된 소스코드 전체가 저급언어로 변환되는 과정
  - 컴파일러: 컴파일을 수행해주는 도구
    - 컴파일러가 소스 코드내에서 오류 하나라도 발견하면 해당 소스 코드는 컴파일에 실패한다.
    - 컴파일러를 통해 저급언어로 변환된 코드는 **목적코드**라고 한다.

- 인터프리터언어: 인터프리터에 의해 소스코드가 한 줄씩 실행되는 고급언어
  - 인터프리터: 소스코드를 한 줄씩 저급언어로 변환하여 실행해주는 도구
    - 소스코드 전체를 저급언어로 변환하는 시간을 기다릴 필요가 없다.
    - 소스코드를 한 줄씩 실행하기 떄문에 소스코드 n번째 줄에 문법 오류가 있더라도 n-1번째 줄까지는 올바르게 수행된다.

### 목적 파일 vs 실행 파일

- 목적 파일: 목적 코드로 이루어진 파일
- 실행 파일: 실행 코드로 이루어진 파일(예 - 윈도우의 .exe확장자 파일)
- 목적파일이 실행파일이 되기 위해선 링킹이라는 작업을 거쳐야한다.

## 명령어의 구조

### 연산 코드와 오퍼랜드

- 명령어

  - 연산코드: 명령어가 수행할 연산(연산자)

    - 연산 코드 유형 종류
      - 데이터 전송
        - MOVE: 데이터를 옮겨라
        - STORE: 메모리에 저장하라
        - LOAD(FETCH): 메모리에서 CPU로 데이터를 가져와라
        - PUSH: 스택에 데이터를 저장하라
        - POP: 스택의 최상단 데이터를 가져와라
      - 산술/논리 연산
        - ADD / SUBTRACT / MULTIPLY / DIVIDE: 덧셈 / 뺄셈 / 곱셈 / 나눗셈을 수행하라
        - INCREMENT / DECREMENT: 오퍼랜드에 1을 더하라 / 오퍼랜드에 1을 빼라
        - AND / OR / NOT: AND / OR / NOT 연산을 해라
        - COMPARE: 두 개의 숫자 또는 TRUE / FALSE 값을 비교하라
      - 제어 흐름 변경
        - JUMP: 특정 주소로 실행 순서를 옮겨라
        - CONDITIONAL JUMP: 조건에 부합할 때 특정 주소로 실행 순서를 옮겨라
        - HALT: 프로그램의 실행을 멈춰라
        - CALL: 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
        - RETURN: CALL을 호출할 때 저장했던 주소로 돌아가라
      - 입출력 제어
        - READ(INPUT): 특정 입출력 장치로부터 데이터를 읽어라
        - WRITE(OUTPUT): 특정 입출력 장치로 데이터를 써라
        - START IO: 입출력 장치를 시작하라
        - TEST IO: 입출력 장치의 상태를 확인하라

  - 오퍼랜드: 연산에 사용할 데이터 or 연산에 사용할 데이터가 저장된 위치(피연산자)
    - 오퍼랜드필드에는 숫자와 문자 등을 나타내는 데이터 또는 메모리나 레지스터 주소가 올 수 있지만 데이터를 직접 명시하기보단 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름이 담긴다. 그래서 오패랜드 필드를 **주소 필드**라고도 한다.
    - 명령어 안에 없을 수도 있고, 하나 또는 여러 개가 있을 수도 있다.
    - 오퍼랜드가 하나도 없는 명령어는 **0-주소 명령어**, 하나인 명령어를 **1-주소 명령어**, 두개인 명령어를 **2-주소 명령어**, 세 개인 명령어를 **3-주소 명령어**라 한다.

### 주소 지정 방식

- 주소 지정 방식: 연산에 사용할 데이터 위치를 찾는 방법

  - 즉시 주소 지정 방식: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
    - 장점: 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기때문에 이하 방식들보다 빠르다.
    - 단점: 표현할 수 있는 데이터의 크기가 작아진다.
  - 직접 주소 지정 방식: 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
    - 장점: 즉시 주소 지정 방식보다 표현할 수 있는 데이터의 크기가 커진다.
    - 단점: 표현할 수 있는 유효 주소에 제한이 생길 수 있다.
  - 간접 주소 지정 방식: 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식

    - 장점: 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어 진다.
    - 단점: 앞선 방식들보다 접근에 더 느리다(두 번의 메모리 접근).

  - 연산에 사용할 데이터가 레지스터에 저장된 경우도 있다. 이 경우 레지스터 주소 지정 방식 또는 레지스터 간접 주소 지정방식을 사용할 수 있다.

  - 레지스터 주소 지정 방식: 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방법
    - 일반적으로 CPU 외부에 있는 메모리에 접근하는 것보다 CPU내부에 있는 레지스터에 접근하는 것이 더 빠르다. 그러므로 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수있다.
    - 단점: 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.
  - 레지스터 간접 주소 지정 방식: 연산에 사용할 데이터를 메모리에 저장하고, 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드에 명시하는 방법
    - 장점: 간접 주소 지정방식보다 빠르다.

### 스택과 큐

- 스택(LIFO): 나중에 저장한 데이터를 가장 먼저 빼내는 데이터 관리 방식(후입선출)

  - PUSH: 스택에 새로운 데이터를 저장하는 명령어
  - POP: 스택에 저장된 데이터를 꺼내는 명령어

- 큐(FIFO): 가장 먼저 저장된 데이터부터 빼내는 데이터 관리 방식(선입선출선)
