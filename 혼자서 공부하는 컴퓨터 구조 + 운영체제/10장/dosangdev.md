# 10-1 프로세스 개요

## 프로세스 직접 확인하기

- 윈도우는 작업관리자의[프로세스]탭에서 확인, 유닉스 체계의 운영체제는 ps명령어로 확인

- 포그라운드 프로세스(foreground process): 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스(background process): 사용자가 보지 못하는 뒤편에서 실행되는 프로세스
  - 데몬(daemon): 사용자와 상호작용하지않고 정해진 일만 수행하는 백그라운드 프로세스(윈도에선 서비스(service)라 한다)

## 프로세스 제어 블록

- CPU는 자원이 한정되어 있기 때문에 타이머 인터럽트를 기준으로 프로세스들은 차례대로 돌아가며 한정된 시간만큼만 CPU를 이용한다
- PCB(Process Control Block): 프로세스와 관련된 정보를 저장하는 자료구조
  - 커널영역에 생성
  - 프로세스 생성 시에 만들고 실행이 끝나면 폐기
  - 해당 프로세스를 식별하기 위해 꼭 **필요한 정보**들이 저장
    - 프로세스 ID(PID): 특정 프로세스를 식별하기 위해 부여하는 **고유**한 번호
    - 레지스터 값: 이전까지 진행했던 작업들을 그대로 이어 실행하기 위해
    - 프로세스 상태
    - CPU 스케줄링 정보: 프로세스가 언제, 어떤 순서로 CPU를 할당받을지에 대한 정보
    - 메모리 관리 정보: 프로세스마다 메모리에 저장된 위치가 다르기 때문(메모리 주소를 알 수있는 정보들이 담김)
    - 사용한 파일과 입출력장치 목록: 프로세스 실행과정에서 특정 입출력장치나 파일을 사용한 정보들

## 문맥 교환

- 문맥: 하나의 프로세스 수행을 재개하기 위해 기억해야 할 정보
- 문맥 교환: 기존 프로세스의 문맥을 PCB에 백업하고, 새로운 프로세스를 실행하기 위해 문맥을 PCB로부터 복구하여
  새로운 프로세스를 실행하는 것

## 프로세스의 메모리 영역

- 프로세스 생성 시

  - 커널영역: PCB 생성
  - 사용자 영역: 4개로 나눠 저장

    - 코드 영역(텍스트 영역)

      - 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장
      - 읽기 전용 공간(쓰기가 금지되어 있음)
      - 정적 할당 영역(크기가 고정된 영역)

    - 데이터 영역

      - 실행되는 동안 유지할 데이터가 저장되는 공간
      - 정적 할당 영역
      - ex) 전역 변수

    - 힙 영역

      - 프로그래머가 직접 할당할 수 있는 저장 공간.
      - 메모리 공간을 반환하지 않는다면 할당한 공간은 메모리 내에 계속 남아 메모리 낭비를 초래한다(**메모리 누수**)
      - 동적 할당 영역

    - 스택 영역

      - 데이터를 일시적으로 저장하는 공간
      - ex) 함수의 실행이 끝나면 사라지는 매개변수, 지역 변수

    - 일반적으로 힙영역은 메모리의 낮은 주소에서 높은 주소로 할당되고 스택영역은 높은 주소에서 낮은 주소로 할당된다

<hr/>

# 10-2 프로세스 상태와 계층 구조

## 프로세스 상태

- 운영체제는 프로세스의 상태를 PCB를 통해 인식하고 관리

  - 생성 상태

    - 이제 막 메모리에 적재되어 PCB를 할당받은 상태
    - 생성 상태를 거쳐 실행할 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU의 할당을 기다린다.

  - 준비 상태

    - 아직 자신의 차례가 아니기에 기다리고 있는 상태
    - 자신의 차례가 되면 CPU를 할당받아 실행상태가 된다.
    - 준비->실행상태로 전환 되는 것을 디스패치(dispatch)라고 한다.

  - 실행 상태

    - CPU를 할당받아 실행 중인 상태
    - 할당된 일정 시간 동안만 CPU 사용
    - 타이머 인터럽트가 발생하면 다시 준비상태로 전환

  - 대기 상태

    - 실행 도중 입출력장치 사용 시 끝날때까지 기다려야한다면 대기 상태가 된다.
    - 입출력 작업이 완료되면 해당 플호세스는 다시 준비상태로 CPU할당을 기다린다.

  - 종료 상태
    - 프로세스가 종료된 상태
    - 운영체제는 PCB와 프로세스가 사용한 메모리를 정리한다

#### 프로세스 상태 다이어 그램

![프로세스상태다이어그램] (https://thebook.io/img/080367/028.jpg)

## 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.
  - 부모 프로세스: 새 프로세스를 생성한 프로세스
  - 자식 프로세스: 부모 프로세스에 의해 생성된 프로세스
  - 각기 다른 PID를 가짐
  - 일부 운영체제에선 자식프로세스 PCB에 PPID(parent process ID)가 기록되기도 한다
  - 자식프로세스는 실행 과정에서 또 다른 자식 프로세스를 생성할 수 있고 이 과정을 도표로 그리면 트리구조를 띄고 이를 **프로세스 계층 구조**라고 한다

## 프로세스 생성 기법

- 순서

  - 부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성
  - 자식 프로세스는 exec를 통해 자신의 메모리 공간을 다른 프로그램으로 교체

- fork: 자기 자신 프로세스의 복사본을 만드는 시스템 호출(복사된 자식이라도 PID값이나 저장된 메모리 위치는 다름)
- exec: 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출

<hr/>

# 10-3 스레드

    스레드: 프로세스를 구성하는 실행의 흐름 단위

## 프로세스와 스레드

- 단일 스레드 프로세스: 실행의 흐름 단위가 하나로 실행되는 프로세스
  -> 스레드가 도입되면서 프로세스를 구성하는 여러 명령어를 동시에 실행할 수 있게 됐다.

- 스레드의 구성

  - 프로세스 내에서 각기 다른 스레드 ID
  - **프로그램 카운터 값을 비롯한 레지스터 값**
  - **스택**

- 프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한채 **프로세스 자원을 공유**하며 실행된다.

## 멀티프로세스와 멀티스레드

- 멀티프로세스: 여러 프로세스를 동시에 실행하는 것
- 멀티스레드: 여러 스레드로 프로세스를 동시에 실행하는 것

- 차이점: 프로세스끼리는 자원 공유X, 스레드끼리는 같은 프로세스 내의 자원을 공유O

  - 예시) 프로세스를 fork하면 PID를 제외한 동일한 프로세스를 다른 메모리에 저장(단일 스레드 프로세스가 2개가 저장된다- 메모리 낭비)
    멀티스레드를 사용하면 같은 프로세스 내의 모든 스레드는 프로세스의 코드, 데이터, 힙, 파일을 공유하고 프로세스 자원을 공유(메모리를 더 효율적으로 사용)

- 멀티스레드의 단점: 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 생길 수 있다.
