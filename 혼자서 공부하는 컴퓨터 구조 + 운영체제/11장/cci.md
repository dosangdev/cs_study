# CPU 스케줄링 개요

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 CPU 스케줄링이라고 한다.

프

## 프로세스 우선순위

- 차례차례 돌아가며 프로세스들을 실행시키는 방법은 비효율적이다.
- 왜냐하면 프로세스들마다 우선순위라는 것이 있기 때문이다.
- 프로세스는 실행 상태와 대기 상태를 반복하며 실행되는데
- 프로세스 종류마다 CPU 사용 비중이 높은 프로세스도 있고, 입출력장치를 위해 대기하는 비중이 높은 프로세스들도 있기 때문이다.
- 참고로 CPU 사용 비중이 높은 프로세스를 CPU 집중 프로세스, 입출력 장치 비중이 높은 프로세스를 입출력 집중 프로세스라고 한다.
- 아무튼 이 두 종류의 프로세스가 동일한 비율로 CPU를 사용하는 것은 비합리적이다.
- 예를 들면, CPU 집중과 입출력 집중 두 프로세스가 동시에 CPU 사용을 요청한다면, 먼저 입출력장치를 끊김없이 작동시키기 위해 (어차피 사용 오래 안하니까) 입출력 집중 프로세스에 배분하고 그 다음 CPU를 더 오래 사용하는 CPU 집중 프로세스에 CPU를 할당하면 된다.
- 이렇게 상황에 맞게, 그리고 프로세스의 중요도에 맞게 프로세스가 CPU를 이용할 수 있도록 하기 위해 운영체제는 프로세스에 우선순위를 둔다.
- 이 우선순위는 PCB에 명시되어 있다.

## 스케줄링 큐

- 운영체제가 우선순위를 확인하기 위해 모든 프로세스의 PCB를 뒤적이는 것은 비효율적이다.
- 운영체제는 그래서 모든 프로세스들을 줄 세우는데 이 줄을 **스케줄링 큐**로 구현하고 관리한다.
- 운영체제는 대부분의 자원을 이 스케줄링 큐로 관리한다.
- 그래서 큐는 다양한 종류가 있는데 대표적으로 준비 큐와 대기 큐가 있다.
- 준비 큐는 CPU를 이용하기 위한 줄을 의미하고, 대기 큐는 입출력 장치 이용을 위한 줄을 의미한다.

## 선점형과 비선점형 스케줄링

- 선점형 스케줄링
    - 운영체제가 실행중인 프로세스로부터 자원을 강제로 빼았을 수 있다.
    - 빼았은 자원을 다른 프로세스에게 할당할 수 있다.
    - 그래서 어느 한 프로세스가 독점적으로 자원을 사용하는 것은 불가능하다.
    - 대부분의 운영체제가 차용하고 있는 방식이다.
    - 단점으로는 골고루 자원을 배분하기 때문에 프로세스끼리의 문맥교환이 자주 발생되어 오버헤드가 발생할 가능성이 있다.
    
- 비선점형 스케줄링
    - 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까지는 다른 프로세스가 끼어들 수 없는 스케줄링 방식이다.
    - 그래서 어느 한 프로세스가 독점적으로 자원을 사용할 수 있는 구조이다.
    - 프로세스마다 사용 시간이 길어지니 문맥교환은 적어져 오버헤드 발생 가능성은 선점형에 떨어지지만, 독점 가능성이 있어서 골고루 자원을 사용할 수 없다는 단점이 있다.

# CPU 스케줄링 알고리즘

작동 방식과 장단점을 이해하는 걸로 충분하다.

## 선입 선처리 스케줄링

- First Come First Served
- 준비 큐에 삽입된 순서대로 프로세스들을 처리하는 비선점형 스케줄링 방식이다.
- 프로세스 A가 10ms 프로세스 B가 5ms 프로세스 C가 2ms의 CPU 사용시간을 가지고 있을 때
    
    A와 B가 먼저 들어가버리면 C는 2ms를 위해 15ms를 기다려야 하는 단점이 있다. 이 현상을 호위 효과라고 한다.
    

## 최단 작업 우선 스케줄링

- 가장 짧은 자원 사용 시간을 가진 프로세스가 먼저 실행된다. SJF 스케줄링이라고 불린다.
- 그러나 기본적으로 비선점형이다.
- 선점형도 있다. 뒤에 나오는 최소 잔여 시간 우선 스케줄링이다.

## 라운드 로빈 스케줄링

- 선입 선처리 방식을 선점형으로 보완한 스케줄링 방식
- 타임슬라이스란 개념이 추가되었다. 타임 슬라이스란 정해진 시간을 의미한다.
- 정해진 시간마다 돌아가며 CPU를 이용하는 선점형 스케줄링 방식이다.
- 타임 슬라이스의 크기는 이 방식에서 매우 중요하다
- 너무 크다면, 호위 효과가 생길 가능성이 있고, 너무 적다면 너무 잦은 문맥교환에 따른 오버헤드가 발생할 수 있기 때문이다.

## 최소 잔여 시간 우선 스케줄링

- 최단 작업 우선 스케줄링과 라운드 로빈 알고리즘을 합친 스케줄링 방식이다.
- 처음에는 타임 슬라이스만큼 CPU를 배분하여 할당하다가 한바퀴가 돌면 남아 있는 시간이 가장 적은 프로세스가 우선권을 가지는 방식이다.

## 우선순위 스케줄링

- 프로세스들에게 우선순위를 부여하는 방식이다.
- 최단 작업 우선 스케줄링과 최소 잔여 우선 스케줄링도 이 방식에 포함된다 볼 수 있다.
- 다만 근본적인 문제를 내포하고 있다. 우선순위가 낮은 프로세스는 우선순위가 높은 프로세스들 때문에 한 없이 연기될 수 있기 때문이다. 이 현상을 기아 현상이라고 한다.
- 이를 방지하기 위한 기법으로는 에이징이 있다. 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식이다.

## 다단계 큐 스케줄링

- 우선순위 스케줄링이 발전된 방식이다.
- 우선순위별로 준비큐를 여러개 준비한다.
- 우선순위 0의 큐가 비어있다면 우선순위 1로 그리고 우선순위 2로 차례차례 넘어가는 방식이다.
- 큐별로 타임 슬라이스를 여러개 지정할 수도 있고, 큐마다 다른 스케줄링 알고리즘을 사용할 수 있다.

## 다단계 피드백 큐 스케줄링

- 다단계 큐 스케줄링은 우선순위가 낮은 프로세스들은 계속 연기될 여지가 있다. 기아 현상
- 이를 보완한 스케줄링 알고리즘이 바로 다단계 피드백 큐 스케줄링이다.
- 다단계 큐와 한 가지 다른 점이 있는데 바로 프로세스들이 큐 사이를 이동할 수 있다는 것이다.
- 새로 준비 상태가 된 프로세스가 있다면 그것을 가장 높은 우선순위 큐에 삽입하고 일정 타임슬라이스 동안 실행하게 둔다.
- 만약 그 프로세스가 타임슬라이스 동안 작업을 마치지 못한다면, 한 단계 아래의 우선순위 큐로 보낸다. 거기서도 작업을 마치지 못한다면
- 또 한 단계 내린다. 그러면서 점차 우선순위가 낮아진다.
- 보통 이런 경우는 CPU 집중 프로세스일텐데, 이렇게 우선순위가 낮아지면 입출력 집중 프로세스들이 자연스레 우선 순위가 높아지면서 실행되고 빠르게 빠져나간다.
- 그리고 CPU 집중 프로세스가 너무 우선순위가 떨어져 있으면, 에이징 기법을 통해 우선 순위를 높여 기아 현상을 예방할 수도 있다.
- 다단계 피드백 큐 스케줄링은 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘으로 알려져 있다.