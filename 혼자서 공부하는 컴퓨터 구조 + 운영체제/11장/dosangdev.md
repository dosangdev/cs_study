# 11-1 CPU 스케줄링 개요

    CPU스케줄링: 운영체제가 프로세스들에게 공정하고 합리적으로 CPU자원을 배분하는 것

## 프로세스 우선순위

- 프로세스의 종류

  - 입출력 집중 프로세스(I/O bound process)

    - 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스
    - 입출력을 위한 대기 상태에 더 많이 머무른다.

  - CPU 집중 프로세스(CPU bound process)

    - 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스
    - 실행상태에 더 많이 머무른다.

  - CPU 집중 프로세스와 입출력 집중 프로세스가 동시에 CPU자원을 요구했을 때
    - 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고,
      그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당한다.

- 운영체제는 각 프로세스의 PCB에 우선순위를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정

#### 용어 노트

- CPU 버스트(CPU burst): CPU를 이용하는 작업
- 입출력 버스트(I/O burst): 입출력장치를 기다리는 작업

## 스케줄링 큐

    운영체제가 매번 일일이 모든 PCB를 검사하여 먼저 자원을 이용할 프로세스를 결정하는 일은 매우 번거롭고 오랜 시간이 걸린다.
    운영체제는 프로세스들에게 줄서는 것을 요구 -> 줄 - 스케줄링 큐(scheduling queue)로 구현하고 관리

- queue의 종류

  - memory queue: 시스템에 적재되기를 기다리는 프로세스들의 줄
  - CPU queue: CPU 사용을 기다리는 프로세스들의 줄
  - I/P queue: 특정 입출력 장치의 사용을 기다리는 프로세스들의 줄

- queue의 상태

  - ready queue: CPU를 이용하고 싶은 프로세스들이 서는 줄

    1. 준비 상태에 있는 프로세스들의PCB는 준비큐의 마지막에 삽입
    2. 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행

  - waiting queue: 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스
    1. 같은 장치를 요구한 프로세스들은 같은 대기큐에서 기다린다.
    2. 입출력이 완료되어 완료 인터럽트가 발생하면 운영체제는 대기큐에서 작업이 완료된 PCB를 찾고,
       이 PCB를 준비상태로 변경한 뒤 대기 큐에서 제거한다.
    3. 해당 PCB는 준비큐로 이동한다.

## 선점형과 비선점형 스케줄링

- 선점형 스케줄링: 지금 CPU를 사용 중인 프로세스로부터 CPU 자원을 빼앗아 다른 프로세스에 할당

  - 현재 대부분의 운영체제에서 사용
  - 장점: 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다.
  - 단점: 문맥 교환 과정에서 오버헤드가 발생할 수 있다.

- 비선점형 스케줄링: CPU를 사용 중인 프로세스의 작업이 끝날 때까지 다른 급한 프로세스를 기다리게 함
  - 장점: 문맥 교환에서 발생하는 오버헤드의 가능성이 선점형 스케줄보다 낮다.
  - 단점: 모든 프로세스가 골고루 자원을 사용할 수 없다.

# 11-2 CPU 스케줄링 알고리즘

## 스케줄링 알고리즘의 종류

- 선입 선처리 스케줄링(=FCFS 스케줄링)

  - CPU를 먼저 요청한 프로세스부터 CPU를 할당하는 비선점형 스케줄링 방식
  - 단점: CPU 사용 시간이 긴 프로세스가 들어오면 기다리는 시간이 길어짐 (호위 효과)

- 최단 작업 우선 스케줄링(=SJF 스케줄링)

  - 준비큐에 삽입된 프로세스들 중 CPU 이용시간의 길이가 가장 짧은 프로세스부터 실행하는 방식
  - 기본적을 비선점형 스케줄링 알고리즘이지만 선점형으로 구현된 **선점형 최단 작업 우선 스케줄링**방식도 있다

- 라운드 로빈 스케줄링

  - 정해진 타임 슬라이스만큼의 시간동안 돌아가며 CPU를 이용하는 선점형 스케줄링(선입 선처리 + 타임슬라이스)
  - 타임슬라이스: 각 프로세스가 CPU를 사용할 수 있는 정해진 시간
  - 타임슬라이스의 크기가 중요
    - 너무 크면 사실상 선입 선처리- 호위효과 발생
    - 너무 작으면 처리하는 일보다 전환하는 데에 힘을 따 쓸 여지가 있다

- 최소 잔여 시간 우선 스케줄링(=SRT 스케줄링) - 최단 작업 우선 스케줄링 + 라운드 로빈 스케줄링

  - 프로세스들은 정해진 타임 슬라이스만큼 CPU를 사용하되, CPU를 사용할 다음 프로세스로는 남아있는 작업 시간이 가장 적은 프로세스가 선택됨

- 우선순위 스케줄링

  - 프로세스들에 우선순위 부여 -> 가장 높은 우선순위를 가진 프로세스부터 실행
  - 최단 작업 우선 스케줄링, 최소 잔여 시간 우선 스케줄링은 넓은 의미에서 우선순위 스케줄링의 일종
  - 먼저 들어온 프로세스더라도 우선순위가 낮으면 실행은 계속 밀린다 (기아 현상)
    - 방지 대책
      - 에이징: 오랫동안 대기한 프로세스의 우선순위를 점차 높이는 방식

- 다단계 큐 스케줄링 - 우선순위 스케줄링의 발전된 형태

  - 우선순위별로 준비큐를 여러 개 사용하는 스케줄링 방식
  - 우선순위가 가정 높은 큐에 있는 프로세스들을 먼저 처리 -> 가장 높은 큐가 비어있으면 그 다음 우선순위 큐에 있는 프로세스들을 처리
  - 각 큐는 라운드 로빈이나 FCFS 등 독자적 스케줄링 사용 가능
  - 큐들 간의 프로세스 이동이 불가(스케줄링 부담이 적지만 유연성이 떨어짐)
  - 기아현상이 발생할 수 있음

- 다단계 피드백 큐 스케줄링 - 다단계 큐 스케줄링의 발전된 형태
  - 다단계 큐 스케줄링과 한가지 다름
    - 큐들 간의 프로세스 이동이 가능
      > 1. 새로 준비상태가 된 프로세스가 있다면 우선 우선순위가 가장 높은 우선순위 큐에 삽입되고 일정시간동안 실행
      > 2. 그리고 만약 해당 큐에서 실행이 끝나지 않는다면 다음 우선순위 큐에 삽입되어 실행
      > 3. 또 안끝나면 또 다음 우선순위 큐에 삽입 -> CPU를 오래 사용해야 하는 프로세스는 점차 우선순위가 낮아짐
      >    즉, CPU집중 프로세스들은 우선순위가 낮아지고, 입출력 집중 프로세스들은 우선순위가 높은 큐에서 실행이 끝남
    - 에이징 기법으로 기아현상 예방 가능
  - 구현이 복잡하지만, 가장 일반적인 CPU 스케줄링 알고리즘
