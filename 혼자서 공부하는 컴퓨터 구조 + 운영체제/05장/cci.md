# 빠른 CPU를 위한 설계 기법

## 클럭

- 컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직인다.
- CPU는 ‘명령어 사이클’이라는 정해진 흐름에 맞춰 명령어들을 실행한다.
- 그렇기 때문에 클럭 속도가 빠를 수록 명령어가 더 빠르게 처리되므로 CPU 성능이 향상된다.
- 클럭 속도는 헤르츠 단위로 측정. 1Hz라면 1초에 1번 반복한다는 뜻이다.
- 클럭 속도를 무제한적으로 높인다고 CPU가 마냥 향상되는 것은 아니다. 바로 발열 때문.

## 코어와 멀티코어

코어 : 코어란 ‘명령어를 실행하는 부품’으로 이해하면 된다. CPU는 시간을 거듭하여 그런 명령어를 실행하는 부품을 여러개 포함하는 부품’으로 확장되었다.

멀티코어(멀티 프로세서) : 코어를 여러개 가지고 있는 CPU

- 코어가 많을 수록 더 좋은 성능을 내지만 코어 수에 비례하여 증가하지는 않는다.
- 왜냐하면 처리할 명령어들을 균등하게 분배하는 것이 이상적으로 이루어지지 않기 때문이다.
- 그래서 CPU 성능을 향상시키려면 처리할 명령어들을 얼마나 적절하게 분배하느냐가 더 중요해진다.

## 스레드와 멀티스레드

스레드 : 실행 흐름의 단위 

- 하드웨어적 스레드 : ‘하나의 코어가 동시에 처리하는 명령어 단위’
    - 하나의 코어로 여러 명령어를 동시에 처리하는 CPU를 멀티스레드 프로세서 혹은 멀티스레드 CPU라고 한다.
- 소프트웨어적 스레드 : ‘하나의 프로그램에서 독립적으로 실행되는 단위’

하드웨어적 스레드가 1코어 1스레드여도 프로그램의 여러 소프트웨어적 스레드를 한번에 실행할 수 있다. 헷갈리지 말자.

## 멀티스레드 프로세서

하나의 CPU에서 한개의 코어가 여러 명령어들을 처리할 수 있는 이유는 바로 레지스터를 여러개 가지고 있기 때문이다.

메모리 속 프로그램의 입장에서 CPU를 봤을 때 하드웨어 스레드는 마치 ‘한 번에 하나의 명령어를 처리하는 CPU’나 다름없다. 2코어 4스레드의 CPU가 있다고 가정했을 때, 프로그램은 이것을 한 번에 하나의 명령어를 처리하는 CPU가 4개 있는 것처럼 본다. 그래서 이런 하드웨어 스레드를 논리 프로세서라고 부르기도 한다.

# 명령어 병렬 처리 기법

빠른 CPU를 만들려면 CPU가 쉬지 않고 작동할 수 있도록 만드는 것도 중요하다.

## 명령어 파이프라인

명령어 처리 과정을 클럭 단위로 나눈 순서

1. 명령어 인출
2. 명령어 해석
3. 명령어 실행
4. 결과 저장
- 같은 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있다.
- 명령어 파이프라인을 사용하여 여러 명령어들을 동시에 처리하는 것이 순차적으로 명령어를 처리하는 것보다 훨씬 효율적이다.
- 하지만 특정 상황에서 성능 향상에 실패하는 경우도 있다. 이러한 상황을 ‘파이프라인 위험’이라고 부른다. 총 3가지 종류가 있다.

### 데이터 위험

- ‘데이터 의존성’에 의해 발생한다.
- 모든 명령어를 동시에 처리할 수 없다.

예시

명령어 1 : R1 ← R2 + R3

명령어 2 : R4 ← R1 + R5

- 명령어 2는 R1의 값이 완전히 도출된 뒤에 실행되어야 온전한 값을 R4에 저장할 수 있다. 하지만 명령어 1의 과정이 채 끝나기 전에 명령어2가 실행된다면 예상과는 전혀 다른 값이 나올 수 있다. 이렇게 데이터에 서로 의존적인 명령어들이 파이프라인처럼 실행되면 발생할 수 있는 위험이 데이터 위험이다.

### 제어 위험

- 주로 분기 등으로 인한 ‘프로그램 카운터의 갑작스러운 변화’에 의해 발생한다.
- 기본적으로 프로그램 카운터는 ‘현재 실행 중인 명령어의 다음 주소’로 갱신된다.
- 하지만 프로그램 실행 흐름이 바뀌어 명령어가 실행되면서 프로그램 카운터 값에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와서 처리 중이었던 명령어들은 아무 쓸모가 없어지게 된다.
- 이를 위해 사용하는 기술 중 하나가 ‘분기 예측’이다. 프로그램이 어디로 분기할지 미리 예측한 후 그 주소를 인출하는 기술이다.

### 구조적 위험

명령어들을 겹쳐 실행하는 과정에서 서로 다른 명령어가 동시에 ALU, 레지스터 등과 같은 CPU 부품을 사용하려고 할 때 발생한다. ‘자원 위험’이라고도 불린다.

## 슈퍼스칼라

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조를 슈퍼스칼라라고 한다.

## 비순차적 명령어 처리

보통 OoOE로 줄여 부른다. 오늘날 CPU 성능 향상에 크게 기여한 기법이자 대부분의 CPU가 차용하는 기법!

# CISC와 RISC

명령어 파이프라이닝과 슈퍼스칼라 기법을 실제로 CPU에 적용하려면 명령어가 파이프라이닝에 최적화되어 있어야 한다. CPU가 인출하고 해석하고 실행하는 명령어가 파이프라이닝 하기 쉽게 생겨야 한다.

## 명령어 집합

명령어의 기본적인 구조와 작동 원리는 큰 틀에서는 벗어나지 않지만, 명령어의 세세한 생김새, 명령어로 할 수 있는 연산, 주소 지정 방식 등은 CPU마다 조금씩 차이가 있다.

CPU가 이해할 수 있는 명령어들의 모음을 명령어 집합 혹은 명령어 집합 구조(ISA)라고 한다. 즉 CPU마다 ISA가 다를 수 있다는 것이다.

- 인텔의 CPU는 x86 혹은 x86-64 ISA를 이해하고, 애플의 CPU는 ARM ISA를 이해한다.
    - 서로 다른 ISA이기 때문에 각 CPU는 서로의 명령어를 이해할 수 없다.
- 같은 소스 코드로 만들어진 같은 프로그램이라 할지라도 ISA가 다르면 CPU가 이해할 수 있는 명령어도 어셈블리어도 달라진다.
- ISA가 달라지면 제어장치가 명령어를 해석하는 방식, 사용되는 레지스터의 종류와 개수 등 CPU의 많은 것들이 달라진다.

명령어 병렬 처리 기법들을 도입하기 유리한 ISA를 알아보자.

## CISC

‘복잡한 명령어 집합을 활용하는 컴퓨터(CPU)’

- x86, x86-64는 대표적인 CISC 기반의 ISA
- 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양한 ‘가변 길이 명령어’를 활용한다.
- 강력한 명령어를 활용한다는 말은 상대적으로 적은 수의 명령어로도 프로그램을 실행할 수 있다는 것을 의미한다. 즉 코드 양이 줄어든다.
- 이런 장점으로 메모리르 최대한 아끼며 개발해야 했던 시절에 CISC는 인기가 높았다.
- 치명적인 단점으로는 활용하는 명령어가 워낙 복잡하고 다양한 기능을 제공하기 떄문에 명령어의 크기와 실행되기까지의 시간이 일정하지 않다. 그리고 복잡한 명령어 때문에 명령어 하나를 실행하는 데에 여러 클럭 주기를 필요로 한다.
- 이는 파이프라인 기법을 구현하는데 장애가 된다. 가급적 1클럭으로 하나의 단계가 실행되는 것이 이상적이기 때문이다.
- 파이프라인이 제대로 동작하지 않는다는 것은 현대 CPU에서 아주 치명적인 약점이다.
- 그리고 CISC가 복잡하고 다양한 명령어를 활용할 수 있다고는 하지만, 사실 대다수의 복잡한 명령어는 그 사용 빈도가 낮다.

## RISC

- 높은 성능을 내기 위해서는 파이프라인을 십분 활용해야 한다.
- 어차피 자주 쓰이는 명령어만 줄곧 사용된다. ‘자주 쓰이는 기본적인 명령어를 작고 빠르게 만드는 것’이 중요하다.

### 특징

- CISC에 비해 명령어의 종류가 적다.
- CISC에 비해 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어를 지향한다.
- 고정 길이 명령어를 활용한다.
- 메모리에 직접 접근하는 명령어를 load, store 두개로 제한할 만큼 메모리 접근을 단순화하고 최소화를 추구한다. 그래서 CISC보다 주소 지정 방식의 종류가 적은 경우가 많다.
- 메모리 접근을 단순화 하는 대신 레지스터를 적극적으로 활용한다. 그래서 CISC보다 레지스터를 이용한 연산이 많고, 일반적인 경우보다 범용 레지스터 개수도 더 많다.