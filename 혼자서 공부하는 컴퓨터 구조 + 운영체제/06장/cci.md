# RAM의 특징과 종류

- 주기억장치의 종류로는 ‘RAM’과 ‘ROM’이 있다.
    - 그 중 우리가 메모리라고 부르는 것은 ‘RAM’이다.
- RAM의 용량이 컴퓨터 성능에 어떤 영향을 미치는지 알아보자
- RAM의 종류 ‘DRAM’, ‘SRAM’, ‘SDRAM’, ‘DDR SDRAM’도 알아보자

## RAM의 특징

- RAM에는 실행할 프로그램의 명령어와 데이터가 저장된다.
- RAM은 컴퓨터의 전원이 꺼지면 저장되어 있던 데이터가 날아간다. 이런 저장 장치를 ‘휘발성 저장 장치’라고 한다.
- 반대로 전원이 꺼져도 저장된 데이터가 유지되는 장치를 ‘비휘발성 저장 장치’라고 한다.
    - 하드디스크, USB 같은 보조기억 장치가 이에 해당한다.

- CPU는 보조기억장치에 직접 접근하지 못한다.
    - 그래서 보통 ‘보관할 대상’은 보조기억장치에 저장하고 ‘실행할 대상’은 주기억장치인 RAM에 저장한다.
    - 만약 실행할 프로그램이 보조기억장치에 있다면 그 프로그램을 메모리로 옮겨서 저장한 다음 CPU가 실행한다.

## RAM의 용량과 성능

- 프로그램을 실행하기 위해서, 보조기억장치에 저장된 프로그램을 RAM으로 불러오는 과정을 거쳐야 한다.
    - 이 때 RAM의 용량이 다수의 프로그램을 동시에 빠르게 실행시키는데 큰 영향을 끼친다.
    - 세 개의 프로그램이 있고 RAM은 단 하나의 프로그램만 저장할 수 있는 크기를 가졌다고 가정해보자. 그러면 하나의 프로그램(A)을 RAM에 저장시켜 실행할 때 나머지 2개의 프로그램은 실행시킬 수 없고, A가 종료되고 나서 둘 중 하나를 실행시킬 때 그것을 보조기억장치에서 RAM에 옮기는 데 시간이 소요된다.
    - 하지만 RAM의 용량이 세개의 프로그램을 저장시킬만큼 충분히 크다면 한번에 세개의 프로그램을 RAM으로 이동시켜, 동시에 실행시킬 수 있다.
    - 다만 RAM의 용량이 무조건 크다고 그에 비례하여 프로그램 실행 속도가 증가하지는 않는다.

## RAM의 종류

### DRAM(Dynamic RAM)

- 동적으로 변하는(사라지는) RAM
- 일정한 시간이 지나면 저장된 데이터가 날아간다.
- 그래서 일정한 주기로 RAM을 재활성화해야 한다.
- 이런 단점에도 불구하고 주기억장치로 일반적으로 쓰이는 RAM이다.
- 왜냐하면 소비 전력이 낮고, 가격이 싸고, 집적도가 높기 때문이다.

### SRAM(Static RAM)

- 정적인 RAM
- 시간이 지나도 데이터가 소실되지 않는다. (물론 전원이 나가면 데이터가 날아간다.)
- 재활성화가 필요 없고, DRAM보다 속도도 빠르다.
- 하지만 주기억장치로는 사용되지 않고, 캐시 메모리에서 사용된다.
- 왜냐하면 소비 전력이 높고, 가격이 높고, 집적도는 낮기 때문이다. 대신 속도가 빠르기 때문에 캐시 메모리에서 사용되는 것이다.

### SDRAM(Synchronous Dynamic RAM)

- DRAM이 발전된 형태로, CPU의 클럭 신호에 맞춰 CPU와 정보를 주고 받을 수 있다.

### DDR SDRAM(Double Data Rate SDRAM)

- 현재 가장 흔히 사용되는 RAM이다. SDRAM에서 대역폭을 넓혀 속도를 빠르게 만든 SDRAM이다.
- 대역폭을 도로로 비유했을 때, SDRAM보다 2배가 큰 도로이다. (그래서 그냥 SDRAM을 SDR SDRAM이라고도 한다.)
- DDR2는 DDR에 2배, DDR3는 DDR2의 2배 이렇게 2의 배수로 대역폭이 늘어나게 된다.

# 메모리의 주소 공간

- 메모리에 저장된 정보의 위치는 주소로 나타낼 수 있다.
- 주소는 두 종류가 있다. 메모리가 참조하는 ‘물리 주소’, CPU와 실행중인 프로그램이 참조하는 ‘논리 주소’

## 물리 주소와 논리 주소

- 메모리에 저장된 정보들은 시시각각 유동적으로 변한다.
    - 프로그램이 종료되고 다시 실행될 때 똑같은 주소에 저장되지 않는다. 삭제 됐다가 다시 메모리에 저장되기 때문이다.
- 그런데 CPU와 실행중인 프로그램은 메모리와 상호작용하여 프로그램 실행을 위해 데이터를 가져와야 한다.
- 하지만 계속 유동적으로 변하는 메모리 주소를 CPU와 실행중인 프로그램은 다 알 수가 없다.
- 그래서 CPU와 실행중인 프로그램이 사용할 수 있는 ‘논리 주소’를 그리고 메모리 하드웨어가 사용하는 ‘물리 주소’ 이렇게 두 종류로 나뉘게 된다.

- 논리 주소 : 실행 중인 프로그램 각각에게 부여된 0번지부터 시작되는 주소를 의미한다.

- 하지만 CPU와 메모리는 서로 소통을 해야 하기 때문에, ‘논리 주소’를 ‘물리 주소’로 변환하는 작업이 필요하다.
- 이 때 변환 작업을 수행해 주는 것이 CPU와 주소 버스 사이에 위치한 MMU(메모리 관리 장치)라는 하드웨어에 의해 수행된다.
- MMU는 CPU가 발생시킨 논리 주소에 베이스 레지스터 값을 더하여 ‘물리 주소’로 변환시킨다.

- 베이스 레지스터 : 프로그램의 가장 작은 물리 주소, 즉 프로그램의 첫 물리 주소(시작점)를 저장한다.
- 변환 작업에서 논리 주소 : 프로그램의 시작점으로부터 떨어진 거리

## 메모리 보호 기법

- ‘논리 주소’가 각 0 ~ 999번지인 메모장, 인터넷 브라우저, 게임이 있다 가정해보자
- 각 프로그램의 ‘물리 주소’는 1000 ~ 1999, 2000 ~ 2999, 3000 ~ 3999이다.
- CPU가 메모장 1500번지에 숫자 100을 저장하라는 명령어를 보내면 어떻게 될까?
- 메모장의 논리 주소는 0 ~ 999번지이기 때문에 CPU의 명령어는 논리 주소를 벗어나게 된다.
- 그렇다면 저 명령어는 논리 주소(1500번지) + 메모장의 베이스 레지스터(1000번지)를 연산하여 ‘물리 주소’ 2500번지에 숫자 100을 저장하게 된다.
- 하지만 2500번지는 인터넷 브라우저이기 때문에 메모장에 100을 저장하라는 명령어와 배치된다.
- 이렇게 다른 프로그램의 영역을 침범할 수 있는 명령어는 위험하기 때문에 논리 주소 범위를 벗어나는 명령어 실행을 방지하고 프로그램을 보호할 수 있는 방법이 있다.
- 한계 레지스터

- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장한다면, 한계 레지스터는 논리 주소의 최대 크기를 저장한다.
- 즉 프로그램의 물리 주소는 베이스 레지스터 ~ 베이스 레지스터 + 한계 레지스터이다.
- CPU는 메모리에 접근하기 전에 항상 논리 주소가 한계 레지스터보다 작은지 검사한다. 만약 한계 레지스터보다 높은 논리 주소에 접근하려 한다면 인터럽트를 발생시켜 실행을 중단한다.

# 캐시 메모리

- CPU는 프로그램을 실행하는 과정에서 메모리에 저장된 데이터를 빈번하게 사용한다.
- 하지만 메모리에서 데이터를 가져오는 시간은 언제나 CPU의 연산 속도보다 느리다.
- 연산 속도에 맞춰 실행을 최대한 빠르게 하기 위해 사용되는 저장 장치가 바로 ‘캐시 메모리’이다.

## 저장 장치 계층 구조

‘빠른 저장 장치’와 ‘용량이 큰 저장 장치’는 양립하기 어렵다.

1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
2. 속도가 빠른 저장 장치는 저장 용량이 작고, 가격이 비싸다.
- 레지스터, 메모리(RAM), USB 메모리를 생각하면 쉽게 이해가 된다.

- 저장 장치 계층 구조는 ‘CPU에 얼마나 가까운가’를 기준으로 나타내는 계층 구조이다.

## 캐시 메모리

- 메모리 접근 속도와 CPU의 연산 속도를 조금이나마 줄이기 위해 만든 메모리이다.
- 레지스터보다 용량이 크고 메모리보다 속도가 빠른 SRAM 기반의 저장 장치
- CPU를 집 RAM을 대형 마트, 그리고 캐시 메모리를 집과 가까운 편의점이라고 비유하면 편하다.
- 캐시 메모리도 CPU에 가까운 순서대로 계층이 나뉘어져 있다.
    - L1은 CPU에 제일 가깝고 CPU 내부에 있다. 그리고 속도가 제일 빠르다. 하지만 용량이 제일 작고 가격이 제일 비싸다.
    - L2는 CPU에 그 다음으로 가깝고 CPU 내부에 있다. 그리고 속도도 중간이다. 용량과 가격도 중간
    - L3는 CPU 외부에 있고 캐시 메모리 중 제일 멀리 있다. 속도도 제일 느리다. 하지만 용량이 제일 크고 가격은 제일 싸다.
- CPU는 L1, L2, L3 순서대로 필요한 데이터가 있는지 검색한다.

## 참조 지역성 원리

- 캐시 메모리는 메모리에서 데이터를 일부 가져와 저장한다.
- 그렇다면 어떤 데이터를 가져오는 것일까? 바로 CPU가 사용할 법한 데이터를 가져와 저장한다.
- 이 때 실제로 가져온 데이터를 CPU가 사용한다면 캐시 히트, 예측이 틀려 메모리로 직접 데이터를 가져와야 한다면 캐시 미스라고 한다.
- 캐시가 히트되는 비율을 캐시 적중율이라고 한다. (캐시 히트 횟수 / 캐시 히트 횟수 + 캐시 미스)

- 대략 우리가 사용하는 컴퓨터의 캐시 적중율을 85 ~ 95%이다.
- 그렇다면 어떻게 CPU가 사용할 법한 데이터인지 알 수 있을까? 바로 참조 지역성의 원리를 사용하여 알 수 있다.
    - CPU는 최근에 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
    - CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

### ‘최근에 접근했던 메모리 공간에 다시 접근하려는 경향’

- 프로그래밍에서 변수는 프로그램이 실행되는 동안 여러 번 사용된다.
- 이렇게 변수에 여러 번 접근하는 것 = 최근에 접근했던 메모리 공간에 다시 접근하려는 경향’ 용어로는 ‘시간 지역성’이라고 한다.

### ‘접근한 메모리 공간 근처를 접근하려는 경향’

- CPU가 실행하려는 프로그램은 보통 관련 데이터들끼리 한데 모여 있다.
    - 워드 프로세서, 웹 브라우저, 게임
- 모여서 저장되기 때문에, CPU가 어느 특정 프로그램을 실행하려 할 때는 그 프로그램의 데이터가 모여 있는 공간 근처를 집중적으로 접근한다.
- 프로그램의 데이터가 모여 있는 공간을 집중적으로 접근 = 접근한 메모리 공간 근처를 접근하려는 경향. 용어로는 ‘공간 지역성’이라고 한다.