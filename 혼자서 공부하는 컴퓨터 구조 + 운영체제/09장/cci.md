# 운영체제를 알아야 하는 이유

## 운영체제란

- 프로그램이 실행될 수 있도록 프로그램에 시스템 자원을 할당하고, 프로그램이 올바르게 실행되도록 도움을 주는 프로그램이다.
- 사용자 영역과 커널 영역으로 나뉜 메모리에서 커널 영역에 적재되어 실행된다.
- 마치 한 국가의 정부와 같이 하드웨어 별로 (CPU, 메모리, 보조기억장치 등) 프로그램들이 잘 동작할 수 있게끔 공정하게 자원을 할당한다.

## 왜 운영체제를 배워야 하는가

- 운영체제가 없다면 하드웨어를 조작하는 코드를 프로그램 개발자가 일일이 만들어줘야 하기 때문이다.
- 운영체제도 프로그램이기 때문에 운영체제를 알게 되면 (어떻게 작동하는지) 대화를 하며 문제를 해결할 수 있기에 꼭 배워야 한다.

# 운영체제의 큰 그림

## 운영체제의 심장 커널

- 운영체제는 현존하는 프로그램 중 가장 큰 프로그램 중 하나이다. 리눅스는 천만줄이 넘는다.
- 이 거대한 프로그램이 응용 프로그램에 제공하는 서비스 중 가장 핵심적인 서비스들이 있는데 이 것들을 담당하는 부분을 바로 커널이라고 한다.
- 운영체제가 설치된 기기에는 모두 커널이 들어있어, 어떤 커널을 쓰느냐에 따라 기기의 성능이 달라질 수 있다.

### 커널에 포함되지 않는 서비스 UI(사용자 인터페이스)

- 그래픽을 기반으로 사용자와 상호작용하는 GUI와 명령어를 기반으로 상호작용하는 CLI가 있다.
- 그저 사용자와 컴퓨터가 상호작용하기 위한 통로일 뿐 커널에 속한 핵심기능은 아니다!

## 이중 모드와 시스템 호출

- 운영체제는 응용 프로그램들이 자원에 직접 접근하는 것을 막는다,
- 그 이유는 한 프로그램이 자원을 혼자 독식하면 기기 내에 큰 문제가 발생할 수 있기 때문이다.
- 하지만 프로그램들은 자원 이용이 필수이므로 운영체제는 대신 이것을 수행해준다.
- 이 때 필요한 것이 이중 모드이다.
- 이중 모드는 사용자 모드와 커널모드로 나뉘어져 있다.
- 사용자모드는 운영체제 서비스를 제공받을 수 없는 실행 모드이다. 일반적으로 응용 프로그램은 사용자 모드로 실행된다.
- 반대로 커널 모드는 운영체제 서비스를 제공받을 수 있는 실행 모드이다.
- 운영체제가 바로 이 커널 모드로 실행되기 때문에 자원에 접근이 가능하다.

- 아무튼 사용자 모드로 작동중인 응용 프로그램이 자원을 이용하려면 커널 모드로의 변경이 필요한데 이 때 서비스를 제공 받기 위해 운영체제에 보내는데 이것을 ‘시스템 호출’이라고 한다.
- 시스템 호출은 일종의 인터럽트이다. 정확히는 소프트웨어 인터럽트라고 한다.

### 시스템 호출 과정

한 응용 프로그램이 하드 디스크에 데이터를 저장하려 한다고 가정해 보자

1. 하드 디스크에 데이터를 저장하는 시스템 호출을 발생시켜 커널모드로 전환
2. 운영체제 내의 ‘하드 디스크에 데이터를 저장하는 코드’를 실행함으로써 하드디스크에 접근
3. 하드 디스크에 접근이 끝났다면 다시 사용자 모드로 복귀하여 실행을 이어간다.

일반적으로 응용 프로그램은 실행과정에서 운영체제 서비스를 빈번하게 이용한다. 그래서 빈번하게 시스템 호출을 발생시키고 사용자 모드와 커널 모드를 오가며 실행된다.

## 운영체제의 핵심 서비스

- 프로세스 관리
    - 실행중인 프로그램을 프로세스라고 한다.
    - 각 프로세스는 상태도, 사용하고자 하는 자원도 다양하다.
    - 그리고 CPU도 하나 당 하나의 프로세스를 처리하고 다른 프로세스를 처리하게 여유가 없다.
    - 그래서 운영체제는 다양한 프로세스를 일목요연하게 관리하고 실행할 수 있어야 한다.
    - ‘프로세스 동기화’가 필수적이고 ‘교착 상태’를 해결해야 한다.
- 자원 접근 및 할당
    - CPU : 하나의 CPU는 한 번에 하나의 프로세스만 실행한다. 그래서 운영체제는 어떤 프로세스가 얼마나 오래 이용하게 할지 결정해야 한다. 이를 CPU 스케줄링이라 한다.
    - 메모리 : 메모리를 각 프로세스 별로 어떻게 할당해야 하는지 그리고 메모리가 부족할 때는 어떤 식으로 해결할 것인지를 결정해야 한다.
    - 입출력장치 : 인터럽트 서비스 루틴은 운영체제가 제공하는 기능으로 커널 영역에 있다.
        - 입출력장치가 발생시키는 하드웨어 인터럽트도 마찬가지이다.
        - 입출력장치가 CPU에 하드웨어 인터럽트 요청 신호를 보내면 CPU는 하던 일을 잠시 백업한 뒤 커널 영역에 있는 인터럽트 서비스 루틴을 실행한다.
        - 이처럼 운영체제는 인터럽트를 처리하는 프로그램, 즉 인터럽트 서비스 루틴을 제공함으로써 입출력 작업을 수행한다.
- 파일 시스템 관리
    - 파일들을 생성 삭제 그리고 그 파일들을 묶어 폴더로 관리하는 이 파일 시스템
    - 이 당연한 것이 바로 운영체제가 제공하는 핵심 서비스중 하나이다.



    # 프로세스 개요

## 프로세스

- 프로세스란 실행되는 프로그램을 뜻한다.
- 실행되기 전까지는 보조기억장치속에 있는 데이터 덩어리일 뿐이지만
- 메모리에 적재되고 실행되는 순간 그 덩어리는 프로세스가 된다. 그리고 이를 ‘프로세스를 생성한다’라고 표현한다.

## 프로세스 종류

- 포그라운드 프로세스 : 사용자가 보는 앞에서 실행되는 프로세스
- 백그라운드 프로세스 : 사용자가 보지 못하는 뒤에서 실행되는 프로세스
    - 사용자와 직접 상호작용할 수 있는 것과 없는 것으로 나뉜다.
    - 유닉스 체계의 운영체제에서는 데몬(daemon)이라 불리고, 윈도우 운영체제에서는 서비스(service)라고 불린다.

## 프로세스 제어 블록 (PCB)

### 사용 이유

- 모든 프로세스는 실행을 위해 CPU를 필요로 한다. 하지만 CPU 자원은 한정되어 있다.
- 이 때 각 프로세스에 자원을 배분하고 프로세스의 실행 순서를 관리하기 위해 운영체제는 프로세스 제어 블록 (PCB)를 이용한다.

### 특징

- PCB는 옷의 상표같은 역할을 한다.
- 프로세스를 식별하기 위해 꼭 필요한 정보가 저장된 자료 구조이다.
- 프로세스가 생성시에 커널영역에 생성되고 프로세스 종료시 폐기된다.

## PCB가 저장하는 정보

### 프로세스 ID

- 특정 프로세스를 식별하기 위해 부여하는 고유한 번호.
- 같은 일을 수행하는 프로그램이라 할지라도 두번 실행하면 PID가 다른 두 개의 프로세스가 생성

### 레지스터 값

- 프로세스는 자신의 실행 차례가 돌아오면 이전까지 사용했던 레지스터의 중간값들을 모두 복원한다.
- 이전에 수행했던 작업들을 이어 수행하기 위해서이다.
- 그래서 PCB안에 프로세스가 전에 실행하며 사용했던 프로그램 카운터를 비롯한 레지스터 값들이 담긴다.

### 프로세스 상태

- 준비 상태인지, 입출력장치를 사용하기 위해 대기상태인지, 실행 상태인지 등의 정보

### CPU 스케줄링 정보

- CPU를 언제 어떤 순서로 할당받을지에 대한 정보

### 메모리 관리 정보

- 프로세스가 어느 메모리 주소에 저장되어 있는지에 대한 정보
- 페이지 테이블 정보, 베이스 레지스터, 한계 레지스터 값 등

### 사용한 파일과 입출력장치 목록

- 실행 과정에서 특정 입출력장치나 파일을 사용한면 PCB에 해당 내용이 명시된다.

## 문맥 교환

- 프로세스는 타이밍 인터럽트가 와서 종료하거나 오류 등으로 종료될 때에 자신이 직전까지 수행했던 중간 정보들을 PCB에 백업한다.
- 그리고 그 다음 프로세스들이 턴을 이어받고 자신의 중간정보를 복원하며 작업을 수행하게 된다.
- 맨 처음 중간 정보를 저장했던 프로세스의 차례가 돌아오면 아까 백업했던 정보를 다시 복원해서 작업을 수행한다.
- 이 과정은 프로세스들이 종료될 때까지 끊임없이 유지되는데 이것을 문맥 교환이라고 한다.
- 문맥은 각 프로세스들의 중간 정보를 뜻하는 단어다.

## 프로세스 메모리 영역

### 정적 할당 영역 : 크기가 고정된 영역

- 코드 영역 (텍스트 영역)
    - 실행할 수 있는 코드, 즉 기계어로 이루어진 명령어가 저장되는 곳
    - CPU가 실행할 명령어가 담겨 있기 때문에 쓰기가 금지되어 있다. 즉 read-only 영역이다.
- 데이터 영역
    - 잠깐 썻다가 없앨 데이터가 아닌 프로그램이 실행되는 동안 유지될 데이터가 저장되는 공간
    - 전역 변수가 대표적이다.

### 동적 할당 영역 : 크기가 변할 수 있는 영역

- 힙 영역
    - 프로그래머가 직접 할당할 수 있는 저장 공간
    - 언젠가는 해당 저장 공간을 반환해야 한다.
    - 하지 않으면 할당한 공간이 메모리 내에 계속 남아 메모리 낭비 (메모리 누수)를 초래한다.
    - 아래에서 위로 쌓인다.
- 스택 영역
    - 데이터를 일시적으로 저장하는 공간
    - 함수의 실행이 끝나면 사라지는 매개 변수, 지역 변수가 대표적이다.
    - 위에서 아래로 쌓인다.

# 프로세스 상태와 계층 구조

## 프로세스 상태

### 생성 상태

- 프로세스가 생성 중인 상태이다.
- 생성되어도 곧바로 실행되지 않고 준비 상태가 되어 CPU 할당을 기다린다.

### 준비 상태

- CPU를 할당 받아 실행할 수 있지만, 자신의 차례가 아니기에 기다리는 상태
- 준비에서 실행 상태로 전환되는 것을 dispatch(디스패치)라고 한다.

### 실행 상태

- CPU를 할당받아 실행중인 상태
- 할당받은 시간을 모두 사용 (타이밍 인터럽트 발생)하면 다시 준비상태가 된다.
- 실행 상태 도중 입출력장치를 사용하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 된다.

### 대기 상태

- 프로세스는 실행 도중 입출력장치를 사용하는 경우가 있다.
- 입출력 작업은 CPU에 비해 처리 속도가 느리다.
- 입출력장치의 작업을 기다리는 상태를 대기 상태(blocked)라고 한다.

### 종료 상태

- 프로세스가 종료된 상태
- 운영체제는 PCB와 사용한 메모리를 정리한다.

### ⇒ 이 상태들을 다이어그램으로 나타낸 것이 프로세스 상태 다이어그램이다.

## 프로세스 계층 구조

- 프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스를 생성할 수 있다.
- 이 때 새 프로세스를 생성한 프로세스를 부모 프로세스 생성된 프로세스를 자식 프로세스라고 한다.
- 엄연히 부모와 자식 프로세스는 다른 프로세스이기에 다른 PID를 가진다.
- 이렇게 운영체제는 프로세스를 계층구조로 관리한다.

## 프로세스 생성 기법

- 우선 부모 프로세스가 실행 중 ‘fork’라는 시스템 호출을 통해 자신의 복제본을 ‘자식 프로세스’로 생성해 낸다.
- 자식 프로세스는 부모 프로세스의 메모리 내용, 열린 파일의 목록 등을 상속받는다.
- 그리고 자식 프로세스는 ‘exec’라는 시스템 호출을 통해 새로운 프로그램으로 자신의 메모리 공간을 덮어 씌운다.
- exec를 호출하면 코드 영역과 데이터 영역의 내용이 실행할 프로그램의 내용으로 바뀌고, 나머지 영역은 초기화된다.

# 스레드

- 스레드란 프로세스를 구성하는 실행의 흐름 단위이다.
- 하나의 프로세스는 여러개의 스레드를 가질 수 있다.
- 고로 하나의 프로세스에서 여러개의 작업을 동시에 처리할 수 있다.

## 프로세스와 스레드

- 하나의 프로세스가 하나의 작업(하나의 실행 흐름의 단위)만 한다는 것은 단일 스레드 프로세스라는 뜻이다.
- 반대로 하나의 프로세스가 여러 작업을 한다는 것은 멀티 스레드 프로세스라는 뜻이다.
- 스레드는 각자가 다른 스레드 ID, 프로그램 카운터 값, 레지스터 값, 스택을 가진다. 그래서 스레드 마다 각기 다른 코드를 실행할 수 있다.
- 프로세스의 스레드들은 실행에 필요한 최소한의 정보만을 유지한 채 프로세스의 자원을 공유하며 실행된다. 이것이 스레드의 핵심이다.

## 멀티 프로세스와 멀티 스레드

- 여러 프로세스를 동시에 실행하는 것을 멀티 프로세스, 하나의 프로세스에서 여러개의 스레드를 동시에 실행하는 것을 멀티 스레드라고 한다.
- 똑같은 작업을 수행하는 프로세스 3개를 동시에 실행하는 멀티 프로세스와, 하나의 프로세스에서 똑같은 작업을 3개 수행하는 멀티 스레드 중 어느 것이 더 효율적일까
- 일단 멀티 프로세스는 서로가 메모리에서 차지하는 공간은 똑같은데, 서로 다른 것은 PID와 메모리 주소 밖에 없다.
- 반대로 멀티 스레드는 프로그램 카운터 값을 포함한 레지스터 값, 스택, 스레드 ID만 다르고 나머지는 프로세스의 자원을 공유하기 때문에 효율적이다.
- 하나 단점이 있다면 멀티 스레드는 자원을 같이 공유하기 때문에 하나의 스레드에 문제가 생기면 프로세스 전체에 문제가 번질 수 있다는 것이다.